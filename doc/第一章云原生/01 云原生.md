# 云原生的技术革命

## 互联网时代的历程

![image-20240406113356982](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404061713045.png)

## 云计算到底是什么

云计算可以根据提供方式的不同分为公共云、私有云和混合云。公共云是由第三方提供商托管的共享计算资源，用户可以按需使用并付费；私有云是由单一组织建立的、为该组织专用的云平台；混合云则是公共云与私有云的结合体，可以根据需要灵活调整。

云计算具备多种基本特点，包括可弹性伸缩、资源共享、按需服务和高可用性。这些特点使得云计算能够满足各种业务需求，提高运行效率和成本控制，同时提供可靠的服务。

目前，云计算服务已经广泛应用于各个领域，包括IT和软件、互联网相关服务以及其他服务。随着技术的不断发展，云计算也在不断演进，与生成式AI、云原生应用安全、高性能计算需求以及边缘计算等趋势相结合，为企业数字化转型提供有力支持。

![image-20240406114040195](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404061713494.png)

## 云计算发展历程

![image-20240406115136411](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404061713011.png)

### CNCF

官网https://www.cncf.io/

CNCF，全称Cloud Native Computing Foundation（云原生计算基金会），是一个致力于推动云原生技术发展和应用的开源组织。它成立于2015年，隶属于Linux基金会，旨在通过维护和集成开源技术，支持编排容器化微服务架构应用，构建一个开放、协作的生态系统，帮助企业实现云原生转型并获得更好的业务效果。

![image-20240406120344846](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404061713519.png)

CNCF项是云原生计算的基础,CNCF项目包括多种类型，如毕业项目（已完成并可投入生产）、孵化项目（仍在开发中但尚未准备好投入生产）以及沙盒项目（处于早期阶段，尚未考虑生产就绪）：

![image-20240406120522943](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404061713469.png)

### 相关名词

![image-20240406115533767](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404061713344.png)



## 云平台的优缺点

### 优势·

稳定性：云平台大量资源，分布式集群部署，保障服务永不宕机（99.99%）·

弹性扩展：按需索取，一键秒级开通需要的资源·

安全性：云上平台生产级可用的完善权限系统·

成本：初期计算资源成本极低，后期更是大量降低运维成本·

易用性：各大云商都有Web管理控制台，可视化，智能化便捷操作

...

### 缺点·

公有云，服务资源被第三方管理，不符合特殊级别的安全场景·

私有云，搭建、维护、升级成本大

...

# 云计算技术架构演进历程

## 体系变革



![image-20240406122442750](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404061713870.png)

## 架构变革

### 单体架构

![image-20240406122621117](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404061712621.png)

### 集群架构阶段

![image-20240406122931447](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404061712351.png)

### 分布式架构阶段

![image-20240406123009417](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404061712166.png)

### 微服务架构

![image-20240406124736316](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404061712645.png)

### 网格化架构

![image-20240406130817114](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404061712382.png)

# 上云的挑战

云存储方案

云负载均衡方案

云缓存方案

云持久化

云运维

云监控

云容器技术

云DevOps

云安全防护



在云环境中，Kubernetes（常简称为K8s）和Spring Cloud都提供了强大的功能来支持微服务和云原生应用的开发、部署和管理。不过，在某些方面，Kubernetes相较于Spring Cloud确实拥有更多的能力。

首先，Kubernetes是一个开源的容器编排平台，允许开发者将应用程序封装在容器中，并提供了一种统一的方式来部署和运行这些容器。K8s不仅管理应用程序的生命周期，包括启动、停止、扩展和更新，还提供了自动化扩展和负载均衡的能力。根据负载情况，K8s可以动态调整应用程序的副本数量，确保性能稳定。此外，K8s还具备先进的容器编排和调度功能，能智能地将容器实例分配到可用的计算节点上，从而最大化资源利用率并确保高可用性。

Spring Cloud则主要是一个用于构建微服务应用的Java框架，它提供了配置中心、API网关、分布式追踪、消息总线、分布式事务和微服务监控等功能。Spring Cloud通过提供统一的编程模型和快速创建应用的能力，显著提高了开发者的微服务开发效率。然而，Spring Cloud主要面向Java语言，这在一定程度上限制了其技术栈的多样性。

上云后，Kubernetes相较于Spring Cloud在某些方面确实拥有更多的能力，尤其是在容器编排、自动化扩展、负载均衡以及资源调度等方面。

![image-20240406131233502](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404061712430.png)



CNCF（Cloud Native Computing Foundation）作为云原生计算领域的开源组织，集成了大量的应用。这些应用涵盖了云原生技术的各个方面，包括容器运行时、容器编排、服务发现、配置管理、网络、存储、安全、监控和日志等。

一些知名的CNCF项目包括Kubernetes、Prometheus、Envoy等，它们在云原生生态系统中扮演着重要角色。这些项目不仅为开发者提供了强大的工具，还推动了云原生技术的不断发展和创新。

![CNCF](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404061334104.png)

最终应用 上云的落地架构就是Kubernetes和ServiceMesh

ServiceMesh是任何应用上云的架构思想和编排理念，有一大堆的落地实现。

![image-20240406133829404](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404061712417.png)

# 云原生的生态系统

云原生：容器、DevOps、微服务、持续交付

![image-20240406135509260](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404061710188.png)



## 云原生常见技术

![image-20240406135624294](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404061710775.png)

# 云原生的术语

## 应用12要素（12-factor apps）

Defines a methodology to create applications that can be delivered on top of cloudinfrastructures. There is a website that explicitly defines the 12 factors and why theymatter. The overall goal is to write applications that run on all clouds, can supportcontinuous integration and deployment, and can scale without significant changes.

定义了一种在云基础设施之上构建和交付应用程序的方法论。这12个要素不仅详细阐述了如何构建云原生应用，还强调了每个要素的重要性。这些要素旨在确保应用程序在各种云平台上都能顺利运行，支持持续集成和部署，并能在不发生重大变更的情况下进行扩展。

### 基准代码(Codebase)：

One codebase tracked in revision control, many deploys .(一份基准代码，多份部署)。

12-Factor应用(译者注：应该是说一个使用本文概念来设计的应用，下同)通常会使用版本控制系统加以管理，如Git, Mercurial, Subversion。一份用来跟踪代码所有修订版本的数据库被称作 代码库（code repository, code repo, repo）。

在类似 SVN 这样的集中式版本控制系统中，基准代码 就是指控制系统中的这一份代码库；而在 Git 那样的分布式版本控制系统中，基准代码 则是指最上游的那份代码库。
基准代码和应用之间总是保持一一对应的关系：

一旦有多个基准代码，就不能称为一个应用，而是一个分布式系统。分布式系统中的每一个组件都是一个应用，每一个应用可以分别使用 12-Factor 进行开发。
多个应用共享一份基准代码是有悖于 12-Factor 原则的。解决方案是将共享的代码拆分为独立的类库，然后使用 依赖管理 策略去加载它们。
尽管每个应用只对应一份基准代码，但可以同时存在多份部署。每份 部署 相当于运行了一个应用的实例。通常会有一个生产环境，一个或多个预发布环境。此外，每个开发人员都会在自己本地环境运行一个应用实例，这些都相当于一份部署。
所有部署的基准代码相同，但每份部署可以使用其不同的版本。比如，开发人员可能有一些提交还没有同步至预发布环境；预发布环境也有一些提交没有同步至生产环境。但它们都共享一份基准代码，我们就认为它们只是相同应用的不同部署而已。

### 依赖（Dependencies）

Explicitly declare and isolate dependencies (显示声明依赖关系）。

大多数编程语言都会提供一个打包系统，用来为各个类库提供打包服务，就像 Perl 的 CPAN 或是 Ruby 的 Rubygems 。通过打包系统安装的类库可以是系统级的（称之为 “site packages”），或仅供某个应用程序使用，部署在相应的目录中（称之为 “vendoring” 或 “bunding”）。
12-Factor规则下的应用程序不会隐式依赖系统级的类库。 它一定通过 依赖清单 ，确切地声明所有依赖项。此外，在运行过程中通过 依赖隔离 工具来确保程序不会调用系统中存在但清单中未声明的依赖项。这一做法会统一应用到生产和开发环境。
例如， Ruby 的 Bundler 使用 Gemfile 作为依赖项声明清单，使用 bundle exec 来进行依赖隔离。Python 中则可分别使用两种工具 – Pip 用作依赖声明， Virtualenv 用作依赖隔离。甚至 C 语言也有类似工具， Autoconf 用作依赖声明，静态链接库用作依赖隔离。无论用什么工具，依赖声明和依赖隔离必须一起使用，否则无法满足 12-Factor 规范。
显式声明依赖的优点之一是为新进开发者简化了环境配置流程。新进开发者可以检出应用程序的基准代码，安装编程语言环境和它对应的依赖管理工具，只需通过一个 构建命令 来安装所有的依赖项，即可开始工作。例如，Ruby/Bundler 下使用 bundle install，而 Clojure/Leiningen 则是 lein deps。
12-Factor 应用同样不会隐式依赖某些系统工具，如 ImageMagick 或是curl。即使这些工具存在于几乎所有系统，但终究无法保证所有未来的系统都能支持应用顺利运行，或是能够和应用兼容。如果应用必须使用到某些系统工具，那么这些工具应该被包含在应用之中。



应用程序不会隐式依赖系统级的库。它通过依赖清单文件（如Gemfile、package.json或requirements.txt）来指定所有依赖项，这样即可确保依赖项的一致性和可重复性。

### 配置分离（Config）：

Store config in the environment（在环境中存储配置）

通常，应用的 配置 在不同 部署 (预发布、生产环境、开发环境等等)间会有很大差异。这其中包括：

数据库，Memcached，以及其他 后端服务 的配置
第三方服务的证书，如 Amazon S3、Twitter 等
每份部署特有的配置，如域名等
有些应用在代码中使用常量保存配置，这与 12-Factor 所要求的代码和配置严格分离显然大相径庭。配置文件在各部署间存在大幅差异，代码却完全一致。
判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。
需要指出的是，这里定义的“配置”并不包括应用的内部配置，比如 Rails 的 config/routes.rb，或是使用 Spring 时 代码模块间的依赖注入关系 。这类配置在不同部署间不存在差异，所以应该写入代码。
另外一个解决方法是使用配置文件，但不把它们纳入版本控制系统，就像 Rails 的 config/database.yml 。这相对于在代码中使用常量已经是长足进步，但仍然有缺点：总是会不小心将配置文件签入了代码库；配置文件的可能会分散在不同的目录，并有着不同的格式，这让找出一个地方来统一管理所有配置变的不太现实。更糟的是，这些格式通常是语言或框架特定的。
12-Factor推荐将应用的配置存储于 环境变量 中（ env vars, env ）。环境变量可以非常方便地在不同的部署间做修改，却不动一行代码；与配置文件不同，不小心把它们签入代码库的概率微乎其微；与一些传统的解决配置问题的机制（比如 Java 的属性配置文件）相比，环境变量与语言和系统无关。
配置管理的另一个方面是分组。有时应用会将配置按照特定部署进行分组（或叫做“环境”），例如Rails中的 development,test, 和 production 环境。这种方法无法轻易扩展：更多部署意味着更多新的环境，例如 staging 或 qa 。 随着项目的不断深入，开发人员可能还会添加他们自己的环境，比如 joes-staging ，这将导致各种配置组合的激增，从而给管理部署增加了很多不确定因素。
12-Factor 应用中，环境变量的粒度要足够小，且相对独立。它们永远也不会组合成一个所谓的“环境”，而是独立存在于每个部署之中。当应用程序不断扩展，需要更多种类的部署时，这种配置管理方式能够做到平滑过渡。

### 后端服务(Backing services）

Treat backing services as attached resources(把后端服务(backing services)当作附加资源)

后端服务是指程序运行所需要的通过网络调用的各种服务，如数据库（MySQL，CouchDB），消息/队列系统（RabbitMQ，Beanstalkd），SMTP 邮件发送服务（Postfix），以及缓存系统（Memcached）。
类似数据库的后端服务，通常由部署应用程序的系统管理员一起管理。除了本地服务之外，应用程序有可能使用了第三方发布和管理的服务。示例包括 SMTP（例如 Postmark），数据收集服务（例如 New Relic 或 Loggly），数据存储服务（如 Amazon S3），以及使用 API 访问的服务（例如 Twitter, Google Maps, Last.fm）。
12-Factor 应用不会区别对待本地或第三方服务。 对应用程序而言，两种都是附加资源，通过一个 url 或是其他存储在 配置 中的服务定位/服务证书来获取数据。12-Factor 应用的任意 部署 ，都应该可以在不进行任何代码改动的情况下，将本地 MySQL 数据库换成第三方服务（例如 Amazon RDS）。类似的，本地 SMTP 服务应该也可以和第三方 SMTP 服务（例如 Postmark ）互换。上述 2 个例子中，仅需修改配置中的资源地址。
每个不同的后端服务是一份 资源 。例如，一个 MySQL 数据库是一个资源，两个 MySQL 数据库（用来数据分区）就被当作是 2 个不同的资源。12-Factor 应用将这些数据库都视作 附加资源 ，这些资源和它们附属的部署保持松耦合。

部署可以按需加载或卸载资源。例如，如果应用的数据库服务由于硬件问题出现异常，管理员可以从最近的备份中恢复一个数据库，卸载当前的数据库，然后加载新的数据库 – 整个过程都不需要修改代码。

### 构建、发布、运行（Build, release, run）

Strictly separate build and run stages(严格分离构建和运行)

基准代码 转化为一份部署(非开发环境)需要以下三个阶段：

构建阶段 是指将代码仓库转化为可执行包的过程。构建时会使用指定版本的代码，获取和打包 依赖项，编译成二进制文件和资源文件。
发布阶段 会将构建的结果和当前部署所需 配置 相结合，并能够立刻在运行环境中投入使用。
运行阶段 （或者说“运行时”）是指针对选定的发布版本，在执行环境中启动一系列应用程序 进程。
12-factor 应用严格区分构建，发布，运行这三个步骤。 举例来说，直接修改处于运行状态的代码是非常不可取的做法，因为这些修改很难再同步回构建步骤。
部署工具通常都提供了发布管理工具，最引人注目的功能是退回至较旧的发布版本。比如， Capistrano 将所有发布版本都存储在一个叫 releases 的子目录中，当前的在线版本只需映射至对应的目录即可。该工具的 rollback 命令可以很容易地实现回退版本的功能。
每一个发布版本必须对应一个唯一的发布 ID，例如可以使用发布时的时间戳（2011-04-06-20:32:17），亦或是一个增长的数字（v100）。发布的版本就像一本只能追加的账本，一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。
新的代码在部署之前，需要开发人员触发构建操作。但是，运行阶段不一定需要人为触发，而是可以自动进行。如服务器重启，或是进程管理器重启了一个崩溃的进程。因此，运行阶段应该保持尽可能少的模块，这样假设半夜发生系统故障而开发人员又捉襟见肘也不会引起太大问题。构建阶段是可以相对复杂一些的，因为错误信息能够立刻展示在开发人员面前，从而得到妥善处理。

### 进程（Processes）

Execute the app as one or more stateless processes(以一个或多个无状态进程运行应用）

运行环境中，应用程序通常是以一个和多个 进程 运行的。
最简单的场景中，代码是一个独立的脚本，运行环境是开发人员自己的笔记本电脑，进程由一条命令行（例如python my_script.py）。另外一个极端情况是，复杂的应用可能会使用很多 进程类型 ，也就是零个或多个进程实例。
12-Factor 应用的进程必须无状态且 无共享 。 任何需要持久化的数据都要存储在 后端服务 内，比如数据库。
内存区域或磁盘空间可以作为进程在做某种事务型操作时的缓存，例如下载一个很大的文件，对其操作并将结果写入数据库的过程。12-Factor应用根本不用考虑这些缓存的内容是不是可以保留给之后的请求来使用，这是因为应用启动了多种类型的进程，将来的请求多半会由其他进程来服务。即使在只有一个进程的情形下，先前保存的数据（内存或文件系统中）也会因为重启（如代码部署、配置更改、或运行环境将进程调度至另一个物理区域执行）而丢失。
源文件打包工具（Jammit, django-compressor） 使用文件系统来缓存编译过的源文件。12-Factor 应用更倾向于在 构建步骤 做此动作——正如 Rails资源管道 ，而不是在运行阶段。
一些互联网系统依赖于 “粘性 session”， 这是指将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程。粘性 session 是 12-Factor 极力反对的。Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。

### 端口绑定（Port binding）

Export services via port binding(通过端口绑定(Port binding)来提供服务)

互联网应用有时会运行于服务器的容器之中。例如 PHP 经常作为 Apache HTTPD 的一个模块来运行，正如 Java 运行于 Tomcat 。
12-Factor 应用完全自我加载 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 通过端口绑定来提供服务 ，并监听发送至该端口的请求。
本地环境中，开发人员通过类似http://localhost:5000/的地址来访问服务。在线上环境中，请求统一发送至公共域名而后路由至绑定了端口的网络进程。
通常的实现思路是，将网络服务器类库通过 依赖声明 载入应用。例如，Python 的 Tornado, Ruby 的Thin , Java 以及其他基于 JVM 语言的 Jetty。完全由 用户端 ，确切的说应该是应用的代码，发起请求。和运行环境约定好绑定的端口即可处理这些请求。
HTTP 并不是唯一一个可以由端口绑定提供的服务。其实几乎所有服务器软件都可以通过进程绑定端口来等待请求。例如，使用 XMPP 的 ejabberd ， 以及使用 Redis 协议 的 Redis 。
还要指出的是，端口绑定这种方式也意味着一个应用可以成为另外一个应用的 后端服务 ，调用方将服务方提供的相应 URL 当作资源存入 配置 以备将来调用。

### 并发（Concurrency）

Scale out via the process model(通过进程模型进行扩展)

任何计算机程序，一旦启动，就会生成一个或多个进程。互联网应用采用多种进程运行方式。例如，PHP 进程作为 Apache 的子进程存在，随请求按需启动。Java 进程则采取了相反的方式，在程序启动之初 JVM 就提供了一个超级进程储备了大量的系统资源(CPU 和内存)，并通过多线程实现内部的并发管理。上述 2 个例子中，进程是开发人员可以操作的最小单位。

在 12-factor 应用中，进程是一等公民。12-Factor 应用的进程主要借鉴于 unix 守护进程模型 。开发人员可以运用这个模型去设计应用架构，将不同的工作分配给不同的 进程类型 。例如，HTTP 请求可以交给 web 进程来处理，而常驻的后台工作则交由 worker 进程负责。
这并不包括个别较为特殊的进程，例如通过虚拟机的线程处理并发的内部运算，或是使用诸如 EventMachine, Twisted, Node.js 的异步/事件触发模型。但一台独立的虚拟机的扩展有瓶颈（垂直扩展），所以应用程序必须可以在多台物理机器间跨进程工作。
上述进程模型会在系统急需扩展时大放异彩。 12-Factor 应用的进程所具备的无共享，水平分区的特性 意味着添加并发会变得简单而稳妥。这些进程的类型以及每个类型中进程的数量就被称作 进程构成 。
12-Factor 应用的进程 不需要守护进程 或是写入 PID 文件。相反的，应该借助操作系统的进程管理器(例如 systemd ，分布式的进程管理云平台，或是类似 Foreman 的工具)，来管理 输出流 ，响应崩溃的进程，以及处理用户触发的重启和关闭超级进程的请求。



### 易处置性（Disposability）

Maximize robustness with fast startup and graceful shutdown（快速启动和优雅终止可最大化健壮性）

12-Factor 应用的 进程 是 易处理（disposable）的，意思是说它们可以瞬间开启或停止。 这有利于快速、弹性的伸缩应用，迅速部署变化的 代码 或 配置 ，稳健的部署应用。
进程应当追求 最小启动时间 。 理想状态下，进程从敲下命令到真正启动并等待请求的时间应该只需很短的时间。更少的启动时间提供了更敏捷的 发布 以及扩展过程，此外还增加了健壮性，因为进程管理器可以在授权情形下容易的将进程搬到新的物理机器上。
进程 一旦接收 终止信号（SIGTERM） 就会优雅的终止 。就网络进程而言，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出。此类型的进程所隐含的要求是HTTP请求大多都很短(不会超过几秒钟)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。
对于 worker 进程来说，优雅终止是指将当前任务退回队列。例如，RabbitMQ 中，worker 可以发送一个NACK信号。 Beanstalkd 中，任务终止并退回队列会在worker断开时自动触发。有锁机制的系统诸如 Delayed Job 则需要确定释放了系统资源。此类型的进程所隐含的要求是，任务都应该 可重复执行 ， 这主要由将结果包装进事务或是使重复操作 幂等 来实现。
进程还应当在面对突然死亡时保持健壮，例如底层硬件故障。虽然这种情况比起优雅终止来说少之又少，但终究有可能发生。一种推荐的方式是使用一个健壮的后端队列，例如 Beanstalkd ，它可以在客户端断开或超时后自动退回任务。无论如何，12-Factor 应用都应该可以设计能够应对意外的、不优雅的终结。Crash-only design 将这种概念转化为 合乎逻辑的理论



### 开发和生产环境等价（Dev/prod parity）

Keep development,staging,and production as similar as possible(尽可能的保持开发，预发布，线上环境相同）

从以往经验来看，开发环境（即开发人员的本地 部署）和线上环境（外部用户访问的真实部署）之间存在着很多差异。这些差异表现在以下三个方面：

时间差异： 开发人员正在编写的代码可能需要几天，几周，甚至几个月才会上线。
人员差异： 开发人员编写代码，运维人员部署代码。
工具差异： 开发人员或许使用 Nginx，SQLite，OS X，而线上环境使用 Apache，MySQL 以及 Linux。
12-Factor 应用想要做到 持续部署 就必须缩小本地与线上差异。 再回头看上面所描述的三个差异:

缩小时间差异：开发人员可以几小时，甚至几分钟就部署代码。
缩小人员差异：开发人员不只要编写代码，更应该密切参与部署过程以及代码在线上的表现。
缩小工具差异：尽量保证开发环境以及线上环境的一致性。
将上述总结变为一个表格如下：
传统应用12-Factor 应用每次部署间隔数周几小时开发人员 vs 运维人员不同的人相同的人开发环境 vs 线上环境不同尽量接近
后端服务 是保持开发与线上等价的重要部分，例如数据库，队列系统，以及缓存。许多语言都提供了简化获取后端服务的类库，例如不同类型服务的 适配器 。下列表格提供了一些例子。
类型语言类库适配器数据库Ruby/RailsActiveRecordMySQL, PostgreSQL, SQLite队列Python/DjangoCeleryRabbitMQ, Beanstalkd, Redis缓存Ruby/RailsActiveSupport::CacheMemory, filesystem, Memcached
开发人员有时会觉得在本地环境中使用轻量的后端服务具有很强的吸引力，而那些更重量级的健壮的后端服务应该使用在生产环境。例如，本地使用 SQLite 线上使用 PostgreSQL；又如本地缓存在进程内存中而线上存入 Memcached。
12-Factor 应用的开发人员应该反对在不同环境间使用不同的后端服务 ，即使适配器已经可以几乎消除使用上的差异。这是因为，不同的后端服务意味着会突然出现的不兼容，从而导致测试、预发布都正常的代码在线上出现问题。这些错误会给持续部署带来阻力。从应用程序的生命周期来看，消除这种阻力需要花费很大的代价。
与此同时，轻量的本地服务也不像以前那样引人注目。借助于Homebrew，apt-get等现代的打包系统，诸如Memcached、PostgreSQL、RabbitMQ 等后端服务的安装与运行也并不复杂。此外，使用类似 Chef 和 Puppet 的声明式配置工具，结合像 Vagrant 这样轻量的虚拟环境就可以使得开发人员的本地环境与线上环境无限接近。与同步环境和持续部署所带来的益处相比，安装这些系统显然是值得的。
不同后端服务的适配器仍然是有用的，因为它们可以使移植后端服务变得简单。但应用的所有部署，这其中包括开发、预发布以及线上环境，都应该使用同一个后端服务的相同版本。

### 日志（Logs）

Treat logs as event streams(把日志当作事件流）

日志 使得应用程序运行的动作变得透明。在基于服务器的环境中，日志通常被写在硬盘的一个文件里，但这只是一种输出格式。
日志应该是 事件流 的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。尽管在回溯问题时可能需要看很多行，日志最原始的格式确实是一个事件一行。日志没有确定开始和结束，但随着应用在运行会持续的增加。
12-factor应用本身从不考虑存储自己的输出流。 不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出（stdout）事件流。开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动。
在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。类似 Logplex 和 Fluentd 的开源工具可以达到这个目的。
这些事件流可以输出至文件，或者在终端实时观察。最重要的，输出流可以发送到 Splunk 这样的日志索引及分析系统，或 Hadoop/Hive 这样的通用数据存储系统。这些系统为查看应用的历史活动提供了强大而灵活的功能，包括：

找出过去一段时间特殊的事件。
图形化一个大规模的趋势，比如每分钟的请求量。
根据用户定义的条件实时触发警报，比如每分钟的报错超过某个警戒线。

### 管理进程（Admin processes）

Run admin/management tasks as one-off processes(后台管理任务当作一次性进程运行）

进程构成（process formation）是指用来处理应用的常规业务（比如处理 web 请求）的一组进程。与此不同，开发人员经常希望执行一些管理或维护应用的一次性任务，例如：

运行数据移植（Django 中的 manage.py migrate, Rails 中的 rake db:migrate）。
运行一个控制台（也被称为 REPL shell），来执行一些代码或是针对线上数据库做一些检查。大多数语言都通过解释器提供了一个 REPL 工具（python 或 perl） ，或是其他命令（Ruby 使用 irb, Rails 使用 rails console）。
运行一些提交到代码仓库的一次性脚本。
一次性管理进程应该和正常的 常驻进程 使用同样的环境。这些管理进程和任何其他的进程一样使用相同的 代码 和 配置 ，基于某个 发布版本 运行。后台管理代码应该随其他应用程序代码一起发布，从而避免同步问题。
所有进程类型应该使用同样的 依赖隔离 技术。例如，如果Ruby的web进程使用了命令 bundle exec thin start ，那么数据库移植应使用 bundle exec rake db:migrate 。同样的，如果一个 Python 程序使用了 Virtualenv，则需要在运行 Tornado Web 服务器和任何 manage.py 管理进程时引入 bin/python 。
12-factor 尤其青睐那些提供了 REPL shell 的语言，因为那会让运行一次性脚本变得简单。在本地部署中，开发人员直接在命令行使用 shell 命令调用一次性管理进程。在线上部署中，开发人员依旧可以使用ssh或是运行环境提供的其他机制来运行这样的进程。

## 蓝绿部署(Blue/Green Deployment)

运行两个相同的生产环境的实践，目的是最大程度地减少停机时间和风险。一个在任何时间都在运行（例如，“蓝色”环境），而另一个（例如，“绿色”环境）处于空闲状态。可以对空闲（绿色）环境进行更改，然后将生产负载切换到该环境。这样可以最大程度地减少停机时间。如果在新的（绿色）环境中出现问题，可以立即将生产负载切换回蓝色环境，从而将风险降到最低。



两个应用集群A：V1.0、B：V1.0，进行版本升级，

1.下线集群B：V1.0进行升级。

2.上线集群B：V1.1，下线集群A:V1.0进行升级

3.上线集群A:V1.0

## 构建包(Buildpacks)

在Cloud Foundry社区内使用此术语来描述软件片段，这些软件片段充当以特定语言编写的应用程序的链接。有二进制和静态文件（HTML,CSS,JavaScript和Nginx)构建包,以及Java,.Net,Go,Node.js,PHP,Python和Ruby的构建包。

## 云应用平台(Cloud Application Platform)

为云计算提供平台即服务（PaaS)的软件。PaaS通常被认为是可用于将软件部署到云计算基础架构的东西。它还可以用于在整个开发，测试和部署周期中连续交付软件。

## 云原生(Cloud-native)

云原生开发不关心在何处托管新应用或服务，而是如何创建它。云原生原则规定，应将应用程序和服务托管在能够扩展到成千上万个自我修复的多租户节点的分布式系统环境中。必须将它们包装在容器中，进行动态管理并围绕微服务进行定位。

## 云提供商界面(Cloud Provider Interface)

云服务提供商与云用户之间的交互界面，它为用户提供了访问和管理云服务的功能。通过云提供商界面，用户可以轻松地访问云资源、进行服务配置、监控和管理云环境。

## 容器(Containers)

容器是一种轻量级的虚拟化技术，可以将应用程序及其所有依赖项打包在一起，形成一个独立的、可移植的运行环境。这种技术使得应用程序可以在不同的环境中运行，无需担心环境依赖的问题，提高了应用程序的可移植性和可重复性。

## 持续集成和持续部署(Continuous Integration/Continuous Delivery(CI/CD))

有时也被称为Continuous Deployment，简称CD）是软件开发中重要的实践方法，尤其在敏捷开发和DevOps文化中。

持续集成强调开发人员提交新代码后，立即进行构建、测试，确保代码改动在整个代码库中的无缝集成。它的目标是快速地识别和解决代码集成问题，并确保所有开发人员都拥有与主代码分支相同的代码和开发环境。为了实现持续集成，需要开发人员定期提交代码，建立一个自动化的集成环境，以及通过构建监控来快速识别并修复构建失败的代码。

而持续部署则是持续集成的延伸，它关注的是自动化地将应用发布到不同的运行环境，如测试环境、准生产环境、生产环境等。通过自动化的手段，持续部署简化了部署的操作过程，降低了部署的复杂度，使得部署成为一个随时可进行的快速活动。通过持续部署，可以尽快验证制品是否存在功能性能等方面的问题，让最终用户尽快使用这些功能，并获得用户的使用反馈。

## DevOps

Development和Operations的组合词，是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。它重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例，并通过自动化“软件交付”和“架构变更”的流程，使得构建、测试、发布软件能够更加地快捷、频繁和可靠。

DevOps的核心特点包括敏捷开发、跨团队合作、高度可伸缩性、风险管理和监控与反馈。它鼓励开发和运维团队采用迭代、快速反馈和持续交付的方式工作，通过持续集成和持续部署的技术手段，开发团队可以频繁地向运维团队交付软件，而运维团队可以实时监控和处理软件的运行状况。

在工具方面，有多种CI/CD工具和自动化部署工具可以支持DevOps的实践，如Jenkins、Gitlab CI/CD、CircleCI、Travis CI、Ansible和Chef等。这些工具可以帮助自动化软件构建、测试、部署和配置等任务，提高工作效率，减少人为错误，并保证软件交付的一致性和可靠性。

## 数字化转型(Digital Transformation)

数字化转型（Digital Transformation）是指企业利用云原生技术，通过开发和部署云原生应用，以实现业务模式的创新、流程的优化和效率的提升。这种转型旨在将传统的、以本地服务器为基础的应用程序和业务流程迁移到云端，并利用云原生的优势，如高可用性、可扩展性和灵活性，来推动企业的数字化进程。

云原生技术为数字化转型提供了强大的技术支撑。通过容器化、微服务、自动化部署等技术手段，企业能够更快速地开发、部署和扩展应用程序，以适应快速变化的市场需求。同时，云原生技术还提供了数据驱动的业务决策能力，帮助企业更好地管理和分析数据，发现商业机会和风险，并基于数据进行精细化的产品定制和市场营销。

## 分布式系统（Distributed System）

分布式系统广泛应用于多个领域，例如大数据处理、物联网、分布式邮件系统、区块链等。在这些应用中，分布式系统的高并发、高性能、高可用性等特性得到了充分体现。例如，在大数据处理中，分布式系统能够存储和处理大量数据；在物联网中，通过分布式的系统架构，能够确保高可用性和稳定性；在区块链中，通过多个节点的共识机制，保证数据的可靠性和不可篡改性。



## laaS (Infrastructure-as-a-Service)



Infrastructure-as-a-Service（IaaS，基础设施即服务）是一种将IT基础设施（包括服务器、存储和网络等）作为服务通过网络提供给用户使用的模式。用户可以通过租用方式从IaaS服务提供商处获得所需的计算资源，而无需自己构建和维护数据中心等硬件设施。

## PaaS (Platform-as-a-Service)

Platform-as-a-Service（PaaS，平台即服务）则是一种将软件研发的平台作为服务提供给用户的商业模式。它实际上是SaaS模式的一种应用，通过将服务器平台或开发环境作为服务提供，使得用户可以更便捷地进行应用程序的开发、测试和部署。

## SaaS (Software-as-a-Service)

Software-as-a-Service（SaaS，软件即服务）是一种通过互联网提供软件应用服务的方式。与传统的软件部署方式相比，SaaS模式允许用户通过互联网访问和使用软件，而无需在本地安装和维护软件。这种交付方式使得软件更加灵活、易用，并降低了企业的IT成本。

## CaaS (Containers-as-a-Service)

Container-as-a-Service（CaaS，容器即服务）是一种云计算服务模式，提供基于容器的应用程序开发、部署和管理服务。随着Docker的兴起而出现,，现在被用来描述以任何容器技术编写的Web应用程序的交付。用户可以使用容器技术将应用程序打包成容器，然后在CaaS平台上进行部署和管理。CaaS通常包括容器引擎、容器编排、容器镜像、网络和存储等服务，为用户提供了高效、灵活的应用程序运行环境。



## FaaS (Function-as-a-Service)

FaaS（Function-as-a-Service），即函数即服务，是一种云计算服务模式。它允许开发人员以功能的形式来构建、计算、运行和管理应用包，无需维护自己的基础架构。FaaS提供基于事件驱动的计算服务（尤其是在loT（物联网）部署中发现的需求），用户可以编写和上传函数代码，当事件触发时，云服务提供商会自动执行这些函数代码，并返回结果。

## 微服务（Microservices)

将一个大型的单体应用程序分解为一组小的、独立的服务，每个服务运行在其自己的进程中，并通常围绕业务能力组织，使用轻量级的通信机制（通常是HTTP资源API）。这些服务可以通过自动化部署机制独立地部署，并且可以用不同的编程语言编写，以及使用不同的数据存储技术。

## 私有云(Private Cloud)

虚拟化并作为云服务交付给单个企业的计算资源和应用程序。计算资源位于本地（也称为本地或“本地”）或第三方托管的托管设备中。私有云的核心属性是专有资源，



## 公有云(Public Cloud)

公有云（Public Cloud）是指第三方提供商为用户提供的能够使用的云，这些云资源是公开的，任何用户都可以购买并使用。公有云的核心属性是共享资源池，这些资源可以被多个用户共同使用，从而实现更高的资源利用率和成本效益。



## 混合云（Hybrid Cloud）

混合云是由一个或多个公有云和私有云环境组合而成的，它利用管理及自动化软件编排成一个虚拟资源池，允许用户通过自助服务门户按需访问其中的资源。这种架构不仅结合了公有云和私有云的优势，还通过加密应用编程接口（API）简化了资源和工作负载在两者之间的迁移操作。



## 多云架构（Multi-Cloud）

一个基础架构，它包含多个云，无论是私有云，公共云还是混合云。多云策略可能涉及使用本地或托管的私有云基础架构以及Amazon Web Services（AWS），Google Compute Engine（GCE)，Microsoft Azure或其他公共云。没有严格的定义可循，因为每个公司都在确定最佳的云技术组合。多云策略可以减轻供应商锁定的可能性，同时还可以微调企业在预算和成本，性能指标，计算和存储的角色以及地理要求之间取得平衡的需求。



## 开源(Open Source)

开源，即开放源代码，是一种软件开发和分发的方式，其中软件的源代码是公开的，并且允许任何人查看、使用、修改和分发。开源软件旨在促进软件的自由使用和协作开发，通过公开源代码，可以吸引更多的开发者参与软件的开发和改进，从而提高软件的质量和安全性。

开源软件的主要优势在于它是由社区而不是由单个公司开发的，以促进更多样化的创新，避免组织团体思维。

## 无服务器（Serverless)

云计算领域中的这一最新术语是指来自云服务提供商或软件平台的服务，它们以秒而不是小时为单位进行度量，并且不会向用户显示特定的服务器实例。对于用户来说，它们似乎是“无服务器的”，即使在后台某处仍运行着实际的服务器。无服务器基础设施被认为是物联网部署的一种有前途的方法，物联网部署通常是事件驱动的，其特征是大量的小数据包爆发，并且需要显着的灵活性来适应在任何给定时期内广泛变化的资源需求。



## 静态文件(Staticfile)

除网络服务器外，不需要后端代码的应用或内容。静态文件应用程序的示例包括前端JavaScript应用程序，静态HTML内容和HTML/JavaScript表单。





## Stemcell

它是一个包含操作系统、标准版软件和一个清单文件的组件，可以被视为Cloud Foundry平台的一部分（Cloud Foundry中的映像），嵌入在支持的环境中运行。Stemcell的“干”源自英文“Stem”，意为“树干”和“起源”，代表着其作为平台构建的基础和起点。

Stemcell的重要性体现在其作为操作系统和Cloud Foundry之间的桥梁，为应用程序提供了一个稳定且一致的运行环境。通过Stemcell，Cloud Foundry能够确保在不同云环境或虚拟机上运行的应用程序具有一致的行为和性能。

## 虚拟机（Virtual Machine)

“虚拟机”是云计算基础架构中的一个实例，对用户而言，它似乎是具有特定资源的真实系统。但是，提供商正在从多个系统的资源中创建此系统，以最大程度地利用数据中心设施内的资源，同时保持用户期望的预期功能和性能。



## 虚拟化（Virtualization)

将计算机的资源（如存储设备、CPU、内存、网络等）不断抽象化，使这些资源在逻辑上变得相互隔离，但在物理上却可以实现共享。通过这种方式，多个操作系统和应用程序可以在同一台物理计算机上独立运行，从而提高了资源的利用率和灵活性。

对于云计算，这意味着可以将服务器资源与其原始系统分离，并合并到虚拟机中。这种方法允许使用每个服务器的更高百分比，并为用户提供一种根据需要扩大和缩小对服务器资源的访问的方法。



# 云原生官方指导学习路线

## 1.容器化

容器化（Containerization）是一种使用容器技术的过程，它允许开发者将应用程序及其依赖项打包成一个轻量级的、可移植的容器，这些容器可以在任何支持容器技术的环境中运行。Docker是容器化技术中最常用的工具之一。

## 2.CI/CD

在设置CI/CD时，每当源代码发生变化时，都应自动触发新容器的构建、测试和部署流程。这包括将容器部署到测试环境，并最终可能部署到生产环境。同时，还需要设置自动化的推出、回滚和测试机制，以确保在部署过程中出现问题时能够迅速恢复并定位问题。

3.**容器编排**和**应用定义**

在容器编排方面，Kubernetes是市场上的领先解决方案。它是一个开源的容器集群管理系统，能够自动化地部署、扩展和管理容器化应用。通过Kubernetes，用户可以轻松地管理容器集群，确保应用的稳定运行和高效扩展。

在应用定义方面，Helm Charts是一个非常重要的工具。Helm是Kubernetes的应用包管理工具，而Helm Charts则是一系列用于封装Kubernetes原生应用程序的YAML文件。通过Helm Charts，用户可以自定义应用程序的元数据，以便于应用程序的分发和管理。无论是部署简单的应用还是复杂的微服务架构，Helm Charts都能提供灵活且强大的支持。

## 4.可观察性和分析

在容器化应用的上下文中，可观察性和分析是至关重要的。为了确保应用的稳定运行和高效性能，需要选择合适的监控、日志记录和追踪解决方案。

在监控方面，Prometheus是一个强大的开源工具，它提供了全面的监控和告警功能。Prometheus可以收集各种指标数据，如CPU使用率、内存占用、网络流量等，并通过Web界面展示和查询这些数据。此外，Prometheus还提供了多种客户端库和Exporter组件，以便与各种应用程序和系统进行集成。

对于日志记录，Fluentd是一个流行的选择。它是一个开源的数据收集器，可以高效地处理大量的日志数据。Fluentd采用了插件式的架构，支持各种输入和输出插件，可以方便地将日志数据路由到不同的目的地，如Elasticsearch、S3等。此外，Fluentd还提供了内存存储和可靠性保障，确保日志数据的完整性和可用性。

在追踪方面，Jaeger是一个分布式追踪系统的优秀代表。它兼容OpenTracing API，可以追踪应用程序中的请求和响应路径，帮助开发者识别性能瓶颈和潜在问题。Jaeger由多个组件组成，包括agent、collector、query和ingester等，可以捕获和处理大量的追踪数据，并提供可视化的界面进行数据分析。

除了选择合适的工具外，还需要考虑如何实现这些工具之间的集成和协同工作。例如，可以将Prometheus与Fluentd集成，以便将监控指标和日志数据进行关联分析；同时，也可以将Jaeger与Prometheus集成，以便在追踪过程中收集更多的性能指标数据。

## 5.服务代理、服务发现和服务网格

在微服务架构和容器化应用中，服务代理、服务发现和服务网格是构建可靠、可扩展和高效系统的关键组件。

服务代理通常负责处理服务的网络请求，如路由、负载均衡和安全控制。它们可以确保请求被正确地路由到目标服务，并在需要时提供负载均衡以平衡服务实例之间的负载。

服务发现是一种机制，用于在分布式系统中自动检测和定位服务实例。这对于动态环境（如容器编排系统）至关重要，因为服务实例的位置和可用性可能会经常变化。CoreDNS是一个快速且灵活的工具，它提供DNS服务发现功能，使得服务之间可以通过域名来相互发现和通信。

服务网格则是一个专用的基础设施层，用于处理服务之间的通信。它提供了诸如服务到服务的认证、监控、追踪和流量控制等高级功能。Envoy和Linkerd是两种流行的服务网格解决方案，它们允许开发人员构建更强大、更灵活的服务间通信。这些服务网格工具不仅提供健康检查（确保服务实例正常运行），还提供了路由和负载均衡功能，以确保请求能够高效地到达目标服务。

## 6.网络、策略和安全

在构建基于容器的应用程序时，网络、策略和安全是三个至关重要的方面。以下是如何在这些方面实施最佳实践的一些建议：

**网络**：
为了启用更灵活的网络，可以使用与容器网络接口（CNI）兼容的网络项目，如Calico、Flannel或Weave Net。这些工具允许在容器化环境中实现复杂的网络拓扑，包括跨主机容器通信、服务发现和网络策略。

**策略**：
OpenPolicy Agent (OPA) 是一个通用的策略引擎，其用途广泛，包括授权、准入控制以及数据过滤。在容器化环境中，可以使用 OPA 来实施细粒度的访问控制，确保只有授权的服务和用户可以访问特定的资源。此外，OPA 还可以用于定义和执行网络策略，限制不同容器之间的通信。

**安全**：
Falco 是一个云原生的异常检测引擎，它可以帮助识别和防止潜在的安全威胁。Falco 通过监视容器和主机级别的行为，并在检测到异常时触发警报，从而提供了一种主动的安全防御机制。此外，为了增强安全性，还应考虑使用加密技术来保护数据的传输和存储，以及实施最小权限原则，确保每个容器只具有执行其任务所需的最小权限。



## 7.分布式数据库和存储

在构建分布式系统时，分布式数据库和存储是确保数据可靠性、可扩展性和性能的关键组件。以下是一些建议的工具和技术，以满足不同的分布式存储需求：

**Vitess**：
当单个数据库无法满足所需的弹性和可扩展性时，Vitess 是一个很好的选择。Vitess 允许你在大规模上运行 MySQL，通过分片将数据分布到多个数据库实例上，从而提高系统的吞吐量和容错能力。它提供了自动分片、负载均衡、故障恢复等高级功能，使得管理分布式 MySQL 集群变得更加容易。

**Rook**：
Rook 是一个存储编排器，它将多种存储解决方案集成到 Kubernetes 中。通过 Rook，你可以方便地部署和管理各种存储后端，如分布式文件系统、对象存储和块存储等。这使得在 Kubernetes 集群中构建复杂的存储解决方案变得更加简单和灵活。

**etcd**：
etcd 是 Kubernetes 的“大脑”，它提供了一个可靠的方式来在机器集群中存储数据。etcd 是一个高可用的键值存储系统，具有一致性保证和分布式特性。它用于存储 Kubernetes 集群的配置信息、元数据以及状态信息等，确保这些信息在整个集群中保持同步和一致性。

**TiKV**：
TiKV 是一个用 Rust 编写的高性能分布式事务键值存储。它结合了 Raft 一致性算法和列式存储引擎，提供了高吞吐量和低延迟的数据访问能力。TiKV 支持 ACID 事务和分布式复制，适用于构建大规模、高并发的数据存储解决方案。

## 8.流处理和消息传递机制

在构建分布式系统时，高性能的流处理和消息传递机制对于确保数据的实时传输和系统的响应性至关重要。当您需要比JSON-REST更高的性能时，可以考虑使用gRPC或NATS。

**gRPC**：
gRPC是一个通用的远程过程调用（RPC）框架，它允许服务之间通过高效、跨语言和跨平台的协议进行通信。gRPC使用Protocol Buffers作为接口定义语言（IDL），并自动生成客户端和服务端的代码，从而简化了开发和维护的复杂性。它支持多种编程语言和平台，并且具有高性能、可扩展性和安全性等优点，适用于构建大规模、低延迟的分布式系统。

**NATS**：
NATS是一个多模式的消息传递系统，它支持请求/响应、发布/订阅以及负载均衡队列等多种消息传递模式。NATS提供了简单、轻量级的API，使开发人员能够轻松地构建分布式应用程序中的消息传递逻辑。NATS具有高性能、可扩展性和可靠性等特点，能够满足实时通信和事件驱动应用的需求。

**CloudEvents**：
CloudEvents是一个规范，用于以通用方式描述事件数据。它定义了一个标准的事件格式，包括事件的类型、源、时间戳等元数据，以及事件数据的结构。通过使用CloudEvents，开发人员可以确保不同系统和服务之间能够以一种一致和可互操作的方式交换事件数据。这有助于促进跨平台、跨组织的事件驱动架构的发展。

## 9.容器注册表和运行时

在容器化环境中，容器注册表和运行时是两个至关重要的组件。它们分别负责存储和管理容器镜像以及执行容器实例。以下是关于Harbor容器注册表以及两种流行的容器运行时containerd和CRI-O的简要介绍。

**Harbor容器注册表**：

Harbor是一个开源的容器镜像仓库，用于存储、签名和扫描容器镜像。它提供了企业级的功能，如镜像的复制、访问控制、安全扫描等，确保容器镜像的安全性和可靠性。通过使用Harbor，您可以轻松地管理和共享容器镜像，促进团队协作和持续集成/持续部署（CI/CD）流程。

**容器运行时**：

容器运行时是负责执行容器实例的组件。虽然Docker是最初和最广泛使用的容器运行时之一，但现在也有其他符合开放容器倡议（OCI）标准的替代方案可供选择。

1. **containerd**：
   containerd是一个高性能、可靠的容器运行时，由Docker贡献给OCI社区。它提供了容器的生命周期管理、镜像存储和分发等功能。containerd是许多现代容器编排系统（如Kubernetes）的底层运行时，因为它具有轻量级、可扩展和安全的特性。
2. **CRI-O**：
   CRI-O（容器运行时接口-O）是另一个符合OCI标准的容器运行时，专为Kubernetes设计。它实现了Kubernetes的容器运行时接口（CRI），允许Kubernetes直接与之交互以管理容器生命周期。CRI-O的目标是提供与Kubernetes紧密集成的轻量级容器运行时，以减少不必要的依赖和开销。

选择适合的容器运行时取决于您的具体需求和环境。如果您正在使用Kubernetes，那么CRI-O可能是一个更好的选择，因为它与Kubernetes紧密集成。而如果您需要更广泛的支持和社区资源，containerd可能是一个更合适的选择。

## 10.软件分发

在软件分发过程中，安全性是至关重要的，特别是当涉及到更新和补丁的部署时。为了确保软件分发的安全性，您应该考虑使用符合 The Update Framework（TUF）标准的工具。Notary 就是这样一个实现 TUF 的工具，它可以帮助您安全地分发和管理软件。

Notary 通过使用数字签名和加密技术，确保软件包的完整性和来源的真实性。它允许您发布和验证软件包的签名，从而确保在分发过程中没有被篡改或替换。此外，Notary 还提供了角色管理和访问控制功能，以确保只有授权的用户才能发布和更新软件包。

通过使用 Notary，您可以减少软件分发过程中的安全风险，并确保您的用户或客户接收到的是安全、完整且可信的软件包。这对于维护系统的稳定性和安全性至关重要，特别是在处理关键更新和补丁时。

![](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404061656177.jpg)